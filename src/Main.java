import java.io.File;
import java.io.IOException;
import java.math.BigInteger;
import java.util.*;
/* Generic DDlog API shared by all programs. */

import ddlogapi.*;

/* Additional program-specific bindings generated by `ddlog`. */
import ddlog.analyze.*;
public class Main {
    static class MyEdge {
        Integer from;
        Integer to;
        public MyEdge(Integer from, Integer to){
            this.from = from;
            this.to = to;
        }
    }
    static class Test {

        private final DDlogAPI api;
        double split_coef = 0.9;
        private final int TRANSACTION_COUNT = 20;
        private int resultDelta = 0;
        private int maxN = 0;
        private ArrayList<MyEdge> edges = new ArrayList<>();
        private HashSet<Integer> endNodes = new HashSet<>();
        private final HashMap<Integer, ArrayList<Integer>> graph = new HashMap<>();

        private int color = 1;

        private MyEdge parseEdge(DDlogRecord record){
            String s = record.toString().substring(5, record.toString().length()-1);
            String[] nums = s.split(",");
            return new MyEdge(Integer.valueOf(nums[0]), Integer.valueOf(nums[1]));
        }
        Test() throws DDlogException, IOException {
            /* Create an instance of the DDlog program with one worker thread. */
            this.api = new DDlogAPI(1, false);
            api.recordCommands("replay.dat", false);
            Scanner scanner = new Scanner(new File("rels.csv")).useDelimiter("[,\n]");
            scanner.nextLine();
            while (scanner.hasNext()) {
                Integer start = Integer.valueOf(scanner.next());
                Integer finish = Integer.valueOf(scanner.next());
                maxN = Integer.max(maxN, Integer.max(start, finish));
                graph.put(start, new ArrayList<>());
                graph.put(finish, new ArrayList<>());
                String type = scanner.next();
                edges.add(new MyEdge(start, finish));
            }
            System.out.println(edges.size());
            scanner = new Scanner(new File("nodes.csv")).useDelimiter("[,\n]");
            scanner.nextLine();
            int cnt = 0;
            this.api.transactionStart();
            analyzeUpdateBuilder builder = new analyzeUpdateBuilder();
            while (scanner.hasNext()) {
                int id = Integer.parseInt(scanner.next());
                String label = scanner.next();
                scanner.next();
                String name = scanner.next();
                String filename = scanner.next();
                boolean overrided = scanner.next().equals("1");
                boolean invoke_call = scanner.next().equals("1");
                boolean call_call = scanner.next().equals("1");
                boolean offset_get = scanner.next().equals("1");
                boolean current_call = scanner.next().equals("1");
                boolean to_string = scanner.next().equals("1");
                boolean get_set_call = scanner.next().equals("1");
                boolean arb_obj_instance = scanner.next().equals("1");
                boolean vuln = scanner.next().equals("True");
                if (vuln){
                    endNodes.add(id);
                }
                builder.insert_Node(BigInteger.valueOf(id), label, name, filename, overrided, invoke_call,
                        call_call, offset_get, current_call, to_string, get_set_call, arb_obj_instance, vuln);
                cnt++;
            }
            builder.applyUpdates(this.api);
            this.api.transactionCommitDumpChanges(this::onCommit);
            System.out.printf("inserted all %s nodes\n", cnt);

        }

        void onCommit(DDlogCommand<DDlogRecord> command) {
            int relid = command.relid();
            switch (relid) {
                case analyzeRelation.Next:
                    resultDelta++;
                    MyEdge edge = parseEdge(command.value());
                    graph.get(edge.from).add(edge.to);
                    maxN = Integer.max(Integer.max(edge.from, edge.to), maxN);
                    break;
                default:
                    throw new IllegalArgumentException("Unknown relation id " + relid);
            }
        }

        ArrayList<ArrayList<MyEdge>> split_sample(ArrayList<MyEdge> edges) {
            int train_size = (int) (edges.size() * split_coef);
            Collections.shuffle(edges);
            ArrayList<MyEdge> train = new ArrayList<>();
            int transaction_size = (edges.size() - train_size) / TRANSACTION_COUNT;
            for (int i = 0; i < train_size; i++) {
                train.add(edges.get(i));
            }
            ArrayList<ArrayList<MyEdge>> ans = new ArrayList<>();
            ans.add(train);
            for (int i = 0; i < TRANSACTION_COUNT; i++) {
                ans.add(new ArrayList<>());
                for (int j = 0; j < transaction_size; j++) {
                    ans.get(i + 1).add(edges.get(train_size + i * transaction_size + j));
                }
            }
            for (int j = train_size + transaction_size * TRANSACTION_COUNT; j < edges.size(); j++) {
                ans.get(0).add(edges.get(j));
            }
            return ans;
        }


        void run() throws DDlogException {
            {
                ArrayList<ArrayList<MyEdge>> data = split_sample(edges);
                System.out.printf("Running test with %s pre-generated operations, %s transactions with %s transaction size\n",
                        data.get(0).size(), TRANSACTION_COUNT, data.get(1).size());
                long res = System.currentTimeMillis();
                analyzeUpdateBuilder builder;
                this.api.transactionStart();
                builder = new analyzeUpdateBuilder();
                for (int i = 0; i < data.get(0).size(); i++) {
                    builder.insert_Edge(new BigInteger(String.valueOf(data.get(0).get(i).from)),
                            new BigInteger(String.valueOf(data.get(0).get(i).to)));
                }
                builder.applyUpdates(this.api);
                this.api.transactionCommitDumpChanges(this::onCommit);

                System.out.println("Generated graph with size:" + data.get(0).size() + " in " +
                        (System.currentTimeMillis() - res) / 1000 + "seconds");
                long ts = System.currentTimeMillis();
                for (int trans_n = 1; trans_n < data.size(); trans_n++) {
                    this.api.transactionStart();
                    builder = new analyzeUpdateBuilder();
                    for (int op_cnt = 1; op_cnt < data.get(trans_n).size(); op_cnt++) {
                        builder.insert_Edge(new BigInteger(String.valueOf(data.get(trans_n).get(op_cnt).from)),
                                new BigInteger(String.valueOf(data.get(trans_n).get(op_cnt).to)));
                    }
                    builder.applyUpdates(this.api);
                    this.api.transactionCommitDumpChanges(this::onCommit);
                    System.out.print((System.currentTimeMillis() - ts) + ", ");
                    ts = System.currentTimeMillis();

                }
                System.out.println();
                res = System.currentTimeMillis() - res;
                System.out.println("Got result summary in: " + (res) + " milliseconds");
                System.out.println("Total changes in output:" + resultDelta);
                System.out.println("One transaction with " + data.get(1).size() + " operations takes avg " + (res / TRANSACTION_COUNT) + " milliseconds");
                System.out.println("Avg changes in one transaction: " + ((double) resultDelta) / TRANSACTION_COUNT);
            }
            this.api.stop();
            //ANALYZE GRAPH
            ArrayList<Integer> parent = new ArrayList<>();
            ArrayList<Boolean> used = new ArrayList<>();
            for(int i = 0; i < maxN+1;i++){
                used.add(false);
                parent.add(-1);
            }

            HashSet<Integer> roots = new HashSet<>();
            for(int i = 0; i < maxN+1; i++){
                if (!used.get(i) && graph.containsKey(i) && graph.get(i).size() > 0){
                    dfs(i, -1, used, roots);
                }
            }
            System.out.println(roots.size());
            ArrayList<Integer> usedNumber = new ArrayList<>();
            for(int i = 0; i < maxN+1;i++){
                usedNumber.add(0);
            }
            for(int i: roots){
                System.out.printf("paths for %s\n", i);

                dfs_paths(i, new ArrayList<>(), usedNumber);
                color++;
                //TODO cycles need to be removed, without it it doesn't work
            }
        }

        void dfs(int v, int parent, ArrayList<Boolean> used, HashSet<Integer> roots) {
            if (parent == -1){
                roots.add(v);
            }
            used.set(v, true);
            for (int u : graph.get(v)) {
                roots.remove(u);
                if(!used.get(u)){
                    dfs(u, v, used, roots);
                }

            }
        }
        void dfs_paths(int v, ArrayList<Integer> curpath, ArrayList<Integer> used){
            curpath.add(v);
            used.set(v, color);
            if (graph.get(v).size() == 0 && endNodes.contains(v)){
                for(int u: curpath){
                    System.out.print(u);
                    System.out.print(" ");
                }
                System.out.println();

            }
            for (int u : graph.get(v)){
                if(used.get(u) < color){
                   dfs_paths(u, curpath, used);
                }
            }
            curpath.remove(curpath.size()-1);
    }
    }
    public static void main(String[] args) throws IOException, DDlogException {
        Test test = new Test();
        test.run();
    }
}
